
 <!DOCTYPE HTML>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  
    <title>Spring事务分析(2)--基于声明式的事务管理实现分析 | 谭锋的博客</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=3, minimum-scale=1">
    
    <meta name="author" content="tanfeng">
    
    <meta name="description" content="借助与spring AOP，spring提供了强大的基于声明式事务管理方式，它很好对事务管理代码和具体业务逻辑进行了解藕，使我们在coding过程不要去关心事务管理的逻辑。下面我们借助一个例子来将分析spring内部的实现。
1. 例子
1.1 datasource配置
1
2
3
4
5
6
7
">
    
    
    
    
    <link rel="alternative" href="itanfeng.cn" title="谭锋的博客" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/author.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/author.jpg">
    
    <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>

  <body>
    <header>
      <div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.svg" alt="谭锋的博客" title="谭锋的博客"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="谭锋的博客">谭锋的博客</a></h1>
				<h2 class="blog-motto">A journey of a thousand miles begins with a single step.</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">Home</a></li>
					
						<li><a href="/archives">Archives</a></li>
					
					<li>
					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="text" id="search" name="q" autocomplete="off" maxlength="20" placeholder="搜索" />
						<input type="hidden" name="q" value="site:itanfeng.cn">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>

    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
	<article itemprop="articleBody" > 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2014/08/17/spring-code-transaction-2/" title="Spring事务分析(2)--基于声明式的事务管理实现分析" itemprop="url">Spring事务分析(2)--基于声明式的事务管理实现分析</a>
  </h1>
  <p class="article-author">By
    
      <a href="itanfeng.cn" title="tanfeng">tanfeng</a>
    </p>
  <p class="article-time">
    <time datetime="2014-08-17T02:10:11.000Z" itemprop="datePublished">2014年08月17日</time>
    更新日期:<time datetime="2014-08-17T04:12:25.000Z" itemprop="dateModified">2014年08月17日</time>
    
  </p>
</header>
	<div class="article-content">
		
		
		<div id="toc" class="toc-article">
			<strong class="toc-title">文章目录</strong>
		<ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-_例子"><span class="toc-number">1.</span> <span class="toc-text">1. 例子</span></a></li><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1_datasource配置"><span class="toc-number">1.1.</span> <span class="toc-text">1.1 datasource配置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2_事务aop部分"><span class="toc-number">1.2.</span> <span class="toc-text">1.2 事务aop部分</span></a></li><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-1_目标对象类代码："><span class="toc-number">1.2.1.</span> <span class="toc-text">1.2.1 目标对象类代码：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-2_配置"><span class="toc-number">1.2.2.</span> <span class="toc-text">1.2.2 配置</span></a></li></ol></ol><li class="toc-item toc-level-1"><a class="toc-link" href="#2-_探究事务内部实现原理"><span class="toc-number">2.</span> <span class="toc-text">2. 探究事务内部实现原理</span></a></li><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1_原生jdbc事务管理方式"><span class="toc-number">2.1.</span> <span class="toc-text">2.1 原生jdbc事务管理方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2_事务代理对象的创建"><span class="toc-number">2.2.</span> <span class="toc-text">2.2 事务代理对象的创建</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3_横切逻辑的织入"><span class="toc-number">2.3.</span> <span class="toc-text">2.3 横切逻辑的织入</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4_事务管理器"><span class="toc-number">2.4.</span> <span class="toc-text">2.4 事务管理器</span></a></li><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-1_创建事务"><span class="toc-number">2.4.1.</span> <span class="toc-text">2.4.1 创建事务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-2_事务回滚"><span class="toc-number">2.4.2.</span> <span class="toc-text">2.4.2 事务回滚</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-3_事务提交"><span class="toc-number">2.4.3.</span> <span class="toc-text">2.4.3 事务提交</span></a></li></ol><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-_偷梁换柱之Connection管理"><span class="toc-number">2.5.</span> <span class="toc-text">2.4. 偷梁换柱之Connection管理</span></a></li><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-1_在DataSource上动手脚"><span class="toc-number">2.5.1.</span> <span class="toc-text">2.4.1 在DataSource上动手脚</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-2_模板方法中的替换"><span class="toc-number">2.5.2.</span> <span class="toc-text">2.4.2 模板方法中的替换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-_总结"><span class="toc-number">2.5.3.</span> <span class="toc-text">3. 总结</span></a></li></ol>
		</div>
		
		<p>借助与spring AOP，spring提供了强大的基于声明式事务管理方式，它很好对事务管理代码和具体业务逻辑进行了解藕，使我们在coding过程不要去关心事务管理的逻辑。下面我们借助一个例子来将分析spring内部的实现。</p>
<h1 id="1-_例子">1. 例子</h1>
<h2 id="1-1_datasource配置">1.1 datasource配置</h2>
<figure class="highlight xml"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"dataSource"</span> <span class="attribute">class</span>=<span class="value">"com.taobao.tddl.jdbc.group.TGroupDataSource"</span> 
<span class="attribute">init-method</span>=<span class="value">"init"</span>&gt;</span> 
    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"appName"</span> <span class="attribute">value</span>=<span class="value">"test"</span> /&gt;</span>
    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"dbGroupKey"</span> <span class="attribute">value</span>=<span class="value">"test"</span> /&gt;</span>
<span class="tag">&lt;/<span class="title">bean</span>&gt;</span>
    
<span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"transactionManager"</span> <span class="attribute">class</span>=<span class="value">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span>
	<span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"dataSource"</span>&gt;</span>
		<span class="tag">&lt;<span class="title">ref</span> <span class="attribute">local</span>=<span class="value">"dataSource"</span> /&gt;</span>
	<span class="tag">&lt;/<span class="title">property</span>&gt;</span>
<span class="tag">&lt;/<span class="title">bean</span>&gt;</span>

<span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"sqlMapClient"</span> <span class="attribute">class</span>=<span class="value">"org.springframework.orm.ibatis.SqlMapClientFactoryBean"</span>&gt;</span>
	<span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"configLocation"</span>&gt;</span> 
	<span class="tag">&lt;<span class="title">bean</span> <span class="attribute">class</span>=<span class="value">"org.springframework.core.io.ClassPathResource"</span>&gt;</span> 
		<span class="tag">&lt;<span class="title">constructor-arg</span>&gt;</span><span class="tag">&lt;<span class="title">value</span>&gt;</span>/sqlmap/sqlmap-auth-config.xml<span class="tag">&lt;/<span class="title">value</span>&gt;</span><span class="tag">&lt;/<span class="title">constructor-arg</span>&gt;</span> 
	<span class="tag">&lt;/<span class="title">bean</span>&gt;</span>
	<span class="tag">&lt;/<span class="title">property</span>&gt;</span>
	<span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"dataSource"</span>&gt;</span>
		<span class="tag">&lt;<span class="title">ref</span> <span class="attribute">local</span>=<span class="value">"dataSource"</span> /&gt;</span>
	<span class="tag">&lt;/<span class="title">property</span>&gt;</span>
<span class="tag">&lt;/<span class="title">bean</span>&gt;</span>
</pre></td></tr></table></figure>

<h2 id="1-2_事务aop部分">1.2 事务aop部分</h2>
<p>实际上对于aop的方式，对于所有的aop方式，声明式事务都支持。请参见spring AOP的几种方式及实现原理分析<br>这里选择比较简单的方式来说明问题，其他的方式实际上是换汤不换药。</p>
<h3 id="1-2-1_目标对象类代码：">1.2.1 目标对象类代码：</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDAOImpl</span> <span class="keyword">extends</span> <span class="title">SqlMapClientDaoSupport</span> <span class="keyword">implements</span> <span class="title">UserDAO</span> {</span>
  
   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doUpdate</span>(...){
     <span class="keyword">this</span>.getSqlMapClientTemplate().update(...);
   }
}
</pre></td></tr></table></figure>

<h3 id="1-2-2_配置">1.2.2 配置</h3>
<figure class="highlight xml"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="code"><pre> <span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"userDAO"</span>  
        <span class="attribute">class</span>=<span class="value">"org.springframework.transaction.interceptor.TransactionProxyFactoryBean"</span>&gt;</span>  
 
        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"transactionManager"</span> <span class="attribute">ref</span>=<span class="value">"transactionManager"</span> /&gt;</span>     
        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"target"</span> <span class="attribute">ref</span>=<span class="value">"userDAOTarget"</span> /&gt;</span>  
         <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"proxyInterfaces"</span> <span class="attribute">value</span>=<span class="value">"com.alibaba.china.spring.dao.UserDao"</span> /&gt;</span>
        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"transactionAttributes"</span>&gt;</span>  
            <span class="tag">&lt;<span class="title">props</span>&gt;</span>  
                <span class="tag">&lt;<span class="title">prop</span> <span class="attribute">key</span>=<span class="value">"*"</span>&gt;</span>PROPAGATION_REQUIRED<span class="tag">&lt;/<span class="title">prop</span>&gt;</span>
            <span class="tag">&lt;/<span class="title">props</span>&gt;</span>  
        <span class="tag">&lt;/<span class="title">property</span>&gt;</span>  
    <span class="tag">&lt;/<span class="title">bean</span>&gt;</span>  
   <span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"userDAOTarget"</span> <span class="attribute">class</span>=<span class="value">"UserDAOImpl"</span>&gt;</span>
       <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"sqlMapClient"</span> <span class="attribute">ref</span>=<span class="value">"sqlMapClient"</span>/&gt;</span>
   <span class="tag">&lt;/<span class="title">bean</span>&gt;</span>
</pre></td></tr></table></figure>

<h1 id="2-_探究事务内部实现原理">2. 探究事务内部实现原理</h1>
<h2 id="2-1_原生jdbc事务管理方式">2.1 原生jdbc事务管理方式</h2>
<p>在事务管理分析之前，我们先来看看针对于原始jdbc方式的事务管理代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td><td class="code"><pre><span class="keyword">try</span> {   
        conn = DriverManager.getConnection(connectionUrl);   

        <span class="comment">//禁止自动提交，设置为false  </span>
        conn.setAutoCommit(<span class="keyword">false</span>);    
        stmt = conn.createStatement();  
 
        <span class="comment">//数据库更新操作1   </span>
        stmt.executeUpdate(sql1);    
        <span class="comment">//数据库更新操作2   </span>
        stmt.executeUpdate(sql2);  
  
        <span class="comment">//事务提交   </span>
        conn.commit();   

    }<span class="keyword">catch</span>(Exception ex) {    
        <span class="comment">//操作不成功则回滚 </span>
        conn.rollback();   
        ex.printStackTrace();   
  
    } <span class="keyword">finally</span>{
    ...
    }
</pre></td></tr></table></figure>

<p>可以看到基于jdbc的事务管理最后是通过Connection来落实。针对于DataSource这样的事务资源的事务管理，经过简化抽取后最终的流程与上面实际上是一致的。</p>
<p>接下来，我们从AOP开始向下探究一下基于DataSource的spring事务实现原理。</p>
<h2 id="2-2_事务代理对象的创建">2.2 事务代理对象的创建</h2>
<p>首先我们来看TransactionProxyFactoryBean这个FactoryBean是如何将事务逻辑切入到具体业务逻辑中的。<br>了解spring AOP的人都知道，要定义一个完整的切面需要包括两个基本组件<br>一个是Pointcut,即定义在业务逻辑的哪个地方插入横切逻辑。<br>一个是Advise，即定义具体的横切逻辑。<br>TransactionProxyFactoryBean是如何将横切逻辑织入到业务逻辑的正确的位置，先来看看类图<br><img src="http://tanfeng.qiniudn.com/blog/2014/08/transaction1.png" alt="TransactionProxyFactoryBean" title="TransactionProxyFactoryBean"><br>完全在我们的意料之中，TransactionProxyFactoryBean包括两个属性，Pointcut,另一个TransactionInterceptor,TransactionInterceptor中实际上封装了一个业务方法的一个完整的事务处理流程，这个将在后面进行分析。<br>TransactionProxyFactoryBean作为一个FactoryBean，与其他创建AOP代理对象的FactoryBean相比，它只是针对于横切逻辑是事务这个特定的情况而已，他们又有很多逻辑是可以共用的，因此，spring把这部分逻辑抽取处理放入了AbstractSingletonProxyFactoryBean类中，该类通过暴露一个createMainInterceptor()方法，用于子类定制主要的（main）拦截器。代理对象的创建是在afterPropertiesSet()方法中，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span>() {
    ... ...
	ProxyFactory proxyFactory = <span class="keyword">new</span> ProxyFactory();

	<span class="comment">//添加前置拦截器</span>
	<span class="comment">//添加由子类定制的拦截器</span>
	proxyFactory.addAdvisor(<span class="keyword">this</span>.advisorAdapterRegistry.wrap(createMainInterceptor()));

	<span class="comment">//添加后置拦截器</span>
            
	proxyFactory.copyFrom(<span class="keyword">this</span>);
	TargetSource targetSource = createTargetSource(<span class="keyword">this</span>.target);
	proxyFactory.setTargetSource(targetSource);

	<span class="comment">//设置通过接口进行代理情况下的配置</span>

	<span class="keyword">this</span>.proxy = getProxy(proxyFactory);
}
</pre></td></tr></table></figure>

<p>实际上TransactionProxyFactoryBean中做的工作很少，主要配置TransactionInterceptor和Pointcut两个属性的相关参数。事务相关的参数都是最终都由TransactionInterceptor来管理。<br>我们来看看reateMainInterceptor()的实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre><span class="keyword">protected</span> Object <span class="title">createMainInterceptor</span>() {
	<span class="keyword">this</span>.transactionInterceptor.afterPropertiesSet();
	<span class="keyword">if</span> (<span class="keyword">this</span>.pointcut != <span class="keyword">null</span>) { <span class="comment">//若指定了pointcut,则创建指定pointcut的Advisor</span>
		<span class="keyword">return</span> <span class="keyword">new</span> DefaultPointcutAdvisor(<span class="keyword">this</span>.pointcut, <span class="keyword">this</span>.transactionInterceptor);
	}
	<span class="keyword">else</span> {
		<span class="comment">//采用默认的pointcut</span>
		<span class="keyword">return</span> <span class="keyword">new</span> TransactionAttributeSourceAdvisor(<span class="keyword">this</span>.transactionInterceptor);
	}
}
</pre></td></tr></table></figure>

<p>需要注意的是，pointcut只是指定哪些方法上添加事务处理。而具体每种方法上添加哪种属性类型的事务，是可以分别配置的，具体是通过TransactionInterceptor中的TransactionAttribute的来指定的。<br>如上面例子中的配置，</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"transactionAttributes"</span>&gt;</span>  
    <span class="tag">&lt;<span class="title">props</span>&gt;</span>  
    	<span class="tag">&lt;<span class="title">prop</span> <span class="attribute">key</span>=<span class="value">"*"</span>&gt;</span>PROPAGATION_REQUIRED<span class="tag">&lt;/<span class="title">prop</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">props</span>&gt;</span>  
<span class="tag">&lt;/<span class="title">property</span>&gt;</span>
</pre></td></tr></table></figure>

<p>实际上会转换成NameMatchTransactionAttributeSource，该类内部通过一个map保存方法名和TransactionAttribute直接的映射关系。<br>若指定了pointcut，会优先使用pointcut来过滤一些不满足pointcut的织入点。如上面的例子上，虽然指定对于所有方法(key=”*”)都使用传播行为为PROPAGATION_REQUIRED的事务，但是若指定了pointcut之后，这个范围就被缩小到满足pointcut条件下的所有方法了。当然若满足pointcut，但不满足事务定义的配置信息，也不会为该方法添加事务<br>分析TranactionAttrbiuteSourceAdvisor代码可以知道，该类内部是以transactionInterceptor中定义的TransactionAttributeSource作为的pointcut的过滤规则。</p>
<h2 id="2-3_横切逻辑的织入">2.3 横切逻辑的织入</h2>
<p>上面提到整个事务的切入实际上都封装在TransactionInterceptor类中，由于这部分内容是实际业务逻辑和事务管理逻辑的结合处，不同逻辑的交汇处，往往也是复杂处。<br>TransactionInterceptor对有事务和无事务的情况都进行了考虑，这里我们只考虑有事务的情况。<br>先来看看类图结构：<br><img src="http://tanfeng.qiniudn.com/blog/2014/08/TransactionInterceptor.png" alt="TransactionInterceptor类结构" title="TransactionInterceptor类结构"><br>首先TransactionInterceptor通过实现MethodInterceptor来处理横切逻辑。同样spring把一些与MethodInterceptor无关的事情放到了TransactionAspectSupport类中，该类中包含两个重要属性：</p>
<ol>
<li>TransactionAttributeSource 管理具体方法与TransactionAttribute之间的映射，用于支持不同方法的事务定义配置（TransactionAttribute）。</li>
<li>PlatformTransactionManager 事务管理器，采用策略模式的方式把事务管理交由具体的接口实现类。<br>在这里已经出现了统一事务管理的三个接口中的两个。<br>在前面通过TransactionProxyFactoryBean，实际上已经帮我们做好了这些属性配置。接下来我们重点分析TransactionInterceptor的invoke方法，这是代理对象方法的入口。<br>该方法按照事务管理器的类型分为两种情况处理。<br>实际上第二种情况是为了支持CallbackPreferringPlatformTransactionManager这个回调的事务管理器接口，使用场景较少，在这里我们只分析第一种情况：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</pre></td><td class="code"><pre><span class="keyword">public</span> Object <span class="title">invoke</span>(<span class="keyword">final</span> MethodInvocation invocation) <span class="keyword">throws</span> Throwable {
    ... ...

	<span class="comment">// 通过TransactionAttributeSource获取事务定义配置TransactionAttribute,若TransactionAttribute为null，则方法为非事务方法</span>
	<span class="keyword">final</span> TransactionAttribute txAttr =
		getTransactionAttributeSource().getTransactionAttribute(invocation.getMethod(), targetClass);
	<span class="keyword">final</span> String joinpointIdentification = methodIdentification(invocation.getMethod());

	<span class="keyword">if</span> (txAttr == <span class="keyword">null</span> || !(getTransactionManager() <span class="keyword">instanceof</span> CallbackPreferringPlatformTransactionManager)) {
			<span class="comment">//根据事务定义，创建事务</span>
		TransactionInfo txInfo = createTransactionIfNecessary(txAttr, joinpointIdentification);
		Object retVal = <span class="keyword">null</span>;
		<span class="keyword">try</span> {
				<span class="comment">//调用目标方法</span>
			retVal = invocation.proceed();
		}
		<span class="keyword">catch</span> (Throwable ex) {
				<span class="comment">//处理目标方法异常</span>
			completeTransactionAfterThrowing(txInfo, ex);
			<span class="keyword">throw</span> ex;
		}
		<span class="keyword">finally</span> {
			cleanupTransactionInfo(txInfo);
		}
		commitTransactionAfterReturning(txInfo);
		<span class="keyword">return</span> retVal;
	}
	<span class="keyword">else</span> {
		... ...
	}
}
</pre></td></tr></table></figure>

<p>从上面的总的逻辑实际上很简单，把事务处理的过程放在try{}catch{}finally之中，这是通用的做法。具体说来包括一下几步：<br><strong>1.</strong> 根据方法名获取方法对应事务配置信息。这一步直接从TransactionAttributeSource中获取。<br><strong>2.</strong> 根据当前的事务配置，创建事务，并将创建的当前事务相关信息包括TransactionAttribute和TransactionStatus保存到TransactionInfo中，TransactionInfo是一个链表结构,除了当前事务信息外，它会保存当前线程的上一个事务。这样就可以支持方法调用栈上不同方法使用不同的事务属性，如代码下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="comment">//开始事务a</span>
a(){  
   <span class="comment">//开始事务b，将事务a状态等信息保存</span>
   b(); 
  <span class="comment">//结束事务b，恢复事务a状态信息</span>
}
<span class="comment">//结束事务a</span>
</pre></td></tr></table></figure>

<p><img src="http://tanfeng.qiniudn.com/blog/2014/08/TransactionInfo.png" alt="TransactionInfo链式结构" title="TransactionInfo链式结构"><br>具体实现在createTransactionIfNecessary方法中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td><td class="code"><pre><span class="keyword">protected</span> TransactionInfo <span class="title">createTransactionIfNecessary</span>(
    		TransactionAttribute txAttr, <span class="keyword">final</span> String joinpointIdentification) {

	<span class="comment">//创建一个代理TransactionAttribute，并用完整的方法名（joinpointIdentification）作为名称</span>
    <span class="comment">//调用PlatformTransactionManager创建事务，并返回事务状态</span>
	TransactionStatus status = <span class="keyword">null</span>;
	<span class="keyword">if</span> (txAttr != <span class="keyword">null</span>) {
		PlatformTransactionManager tm = getTransactionManager();
		<span class="keyword">if</span> (tm != <span class="keyword">null</span>) {
			status = tm.getTransaction(txAttr);
		}
		<span class="keyword">else</span> {
			<span class="keyword">if</span> (logger.isDebugEnabled()) {
				logger.debug(<span class="string">"Skipping transactional joinpoint ["</span> + joinpointIdentification +
							<span class="string">"] because no transaction manager has been configured"</span>);
			}
		}
	}              
    <span class="comment">//将事务定义，状态，封装成一个TransactionInfo，并绑定到当前线程中(ThreadLocal)，               </span>
    <span class="comment">//需要注意的是TransactionInfo在绑定到当前线程时，会把当前线程中原先的TransactionInfo保存起来。便于事务嵌套。</span>
    <span class="keyword">return</span> prepareTransactionInfo(txAttr, joinpointIdentification, status);
        
}
</pre></td></tr></table></figure>

<p>这里需要重点研究是的PlatformTransactionManager.getTransaction()方法，不同类型的事务这里实现会不同。后面将会以例子中的DataSourceTransactionManager为例分析这个实现过程。<br><strong>3.</strong> 调用目标方法。当然在这里面还有可能调用其它方法，并且也使用了事务管理，形成事务重叠，但还是使用上面的这份代码，一样的逻辑，因此不再这样递归分析。后面将会以例子中分析spring是从如何从底层让目标方法支持事务的。<br><strong>4.</strong> 目标方法执行异常后的处理，通过TransactionAttribute的回调接口判断对于抛出的异常类型回滚还是继续提交。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">completeTransactionAfterThrowing</span>(TransactionInfo txInfo, Throwable ex) {
<span class="keyword">if</span> (txInfo.transactionAttribute.rollbackOn(ex)) {
    getTransactionManager().rollback(txInfo.getTransactionStatus());
}<span class="keyword">else</span>{
    getTransactionManager().commit(txInfo.getTransactionStatus());}
}
</pre></td></tr></table></figure>

<p><strong>5.</strong> 在finally中进行清理工作，主要把老的TransactionInfo替换回去,使当前事务的上一个事务能够继续。<br><strong>6.</strong> 目标方法正常结束，则提交事务。<br>这其实是一个很通用事务处理逻辑过程，接下来我们具体分析PlatformTransactionManager如何创建事务，回滚及提交的。</p>
<h2 id="2-4_事务管理器">2.4 事务管理器</h2>
<p>PlatformTransactionManager抽象了事务管理的三个统一的入口方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PlatformTransactionManager</span> {</span>
  <span class="comment">//创建事务</span>
  TransactionStatus getTransaction(TransactionDefinition definition) <span class="keyword">throws</span> TransactionException;
  <span class="comment">//提交事务</span>
  <span class="keyword">void</span> commit(TransactionStatus status) <span class="keyword">throws</span> TransactionException;
  <span class="comment">//回滚事务</span>
  <span class="keyword">void</span> rollback(TransactionStatus status) <span class="keyword">throws</span> TransactionException;
}
</pre></td></tr></table></figure>

<p>以DataSourceTransactionManager为例分析：<br><img src="http://tanfeng.qiniudn.com/blog/2014/08/TransactionMananger.png" alt="DataSourceTransactionManager" title="DataSourceTransactionManager"><br>AbstractPlatformTransactionManager封装了采用模板模式规定了三个事务管理方法的基本逻辑，而将与具体事务资源相关的内容通过抽象方法开放给子类实现。具体说来主要包括以下几个方面：<br><strong>1.</strong> 对于getTransaction()方法：<br><strong>1.1</strong> 判断是否存在当前事务，然后根据当前事务存在与否进行不同的操作。<br><strong>1.2</strong> 结合当前是否存在当前事务，然后根据根据传入的事务定义的传播行为执行后续的逻辑，如挂起当前事务，创建事务失败则恢复当前事务等。<br><strong>2.</strong> 对于commit()方法<br>在提交事务之前检查事务是否是readOnly,若是，则用回滚代替事务提交。<br><strong>3.</strong> 对于rollback() 方法，在事务回滚后，清理并恢复事务的状态。<br>接下来从代码层面分析一下三个方法的大体逻辑</p>
<h3 id="2-4-1_创建事务">2.4.1 创建事务</h3>
<p>创建事务的逻辑定义在AbstractPlatformTransactionManager类的getTransaction()方法中，中间省去一些相对不重要的代码（用//…注释代替）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="keyword">final</span> TransactionStatus <span class="title">getTransaction</span>(TransactionDefinition definition) <span class="keyword">throws</span> TransactionException {
    	Object transaction = doGetTransaction(); <span class="comment">//获取事务对象，这里是暴露给子类来提供。</span>

	<span class="comment">//... 获取日志是否是debug级别</span>

	<span class="keyword">if</span> (definition == <span class="keyword">null</span>) {
		<span class="comment">//没有传入事务定义信息，则采用默认配置。</span>
		definition = <span class="keyword">new</span> DefaultTransactionDefinition();
	}
    <span class="comment">//如果存在当前事务，则根据事务传播行为，定义接下来事务的创建逻辑。</span>
	<span class="keyword">if</span> (isExistingTransaction(transaction)) {
		<span class="keyword">return</span> handleExistingTransaction(definition, transaction, debugEnabled);
	}
    <span class="comment">//不存在当前事务，则着手创建新的事务</span>
	<span class="comment">//事务超时时间配置错误，直接抛异常</span>
	<span class="keyword">if</span> (definition.getTimeout() &lt; TransactionDefinition.TIMEOUT_DEFAULT) {
		<span class="keyword">throw</span> <span class="keyword">new</span> InvalidTimeoutException(<span class="string">"Invalid transaction timeout"</span>, definition.getTimeout());
	}
    <span class="comment">//接着根据事务定义的传播行为创建事务</span>
	<span class="comment">// 传播行为为:PROPAGATION_MANDATORY,而当前事务不存在，很明显，只能抛异常了，其他情况，则可以继续</span>

	<span class="keyword">if</span> (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_MANDATORY) {
		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalTransactionStateException(
					<span class="string">"No existing transaction found for transaction marked with propagation 'mandatory'"</span>);
	}<span class="keyword">else</span> <span class="keyword">if</span> (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRED ||
		definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW ||
			definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED)
		SuspendedResourcesHolder suspendedResources = suspend(<span class="keyword">null</span>); <span class="comment">//挂起事务</span>
			
		<span class="keyword">try</span> {
			doBegin(transaction, definition); <span class="comment">//调用子类的模板方法，创建新事务</span>
		}
		<span class="keyword">catch</span> (TransactionException ex) {
			resume(<span class="keyword">null</span>, suspendedResources); <span class="comment">//抛出异常则，恢复挂起的事务</span>
			<span class="keyword">throw</span> ex;
		}
		<span class="keyword">boolean</span> newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER); <span class="comment">//判断是否需要同步</span>
		<span class="keyword">return</span> newTransactionStatus(
					definition, transaction, <span class="keyword">true</span>, newSynchronization, debugEnabled, suspendedResources);
	}<span class="keyword">else</span> {
			
		<span class="keyword">boolean</span> newSynchronization = (getTransactionSynchronization() == SYNCHRONIZATION_ALWAYS);
		<span class="keyword">return</span> newTransactionStatus(definition, <span class="keyword">null</span>, <span class="keyword">true</span>, newSynchronization, debugEnabled, <span class="keyword">null</span>);
	}
}
</pre></td></tr></table></figure>

<p>针对于DataSourceTransactionManager的doGetTransaction()方法实现，从代码看，逻辑很简单：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre>    <span class="keyword">protected</span> Object <span class="title">doGetTransaction</span>() {
		DataSourceTransactionObject txObject = <span class="keyword">new</span> DataSourceTransactionObject();
		txObject.setSavepointAllowed(isNestedTransactionAllowed());
		ConnectionHolder conHolder =
		    (ConnectionHolder) TransactionSynchronizationManager.getResource(<span class="keyword">this</span>.dataSource);
		txObject.setConnectionHolder(conHolder, <span class="keyword">false</span>);
		<span class="keyword">return</span> txObject;
	}
</pre></td></tr></table></figure>

<p>它会创建一个并返回一个DataSourceTransactionObject，它会被设置两个属性，一个是否支持savepoint，一个对用于保存数据库连接的ConnectionHolder。ConnectionHolder是通过TransactionSynchronizationManager从当前线程的ThreadLocal中获取，TransactionSynchronizationManager相当于是一个事务资源管理器。目前只看到通过TransactionSynchronizationManager从当前线程中获取ConnectionHolder,那它又是何时绑定到当前线程的呢？不急，后面肯定会碰到。</p>
<blockquote>
<p>作为基于DataSource的事务管理，实际上数据库连接Connection是最为核心的资源，事务的管理控制最终都会由Connection的相关方法来完成。</p>
</blockquote>
<p>isExistingTransaction()方法实际上是根据ConnectionHolder中Connection是否存在，并且是active来判断的。<br>根据这个状态分为两种情况:</p>
<p><strong>a. 当前事务存在</strong></p>
<p>对于当前事务存在的情况，由handleExistingTransaction()方法统一处理，该方法主要是根据definition中指定事务传播行为和当前事务的关系进行处理。<br>在分析之前先了解spring中定义的传播行为，便于我们理解代码的逻辑：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="comment">PROPAGATION_REQUIRED</span> <span class="literal">-</span><span class="literal">-</span> <span class="comment">支持当前事务，如果当前没有事务，就新建一个事务。这是最常见的选择。</span> 
<span class="comment">PROPAGATION_SUPPORTS</span> <span class="literal">-</span><span class="literal">-</span> <span class="comment">支持当前事务，如果当前没有事务，就以非事务方式执行。</span> 
<span class="comment">PROPAGATION_MANDATORY</span> <span class="literal">-</span><span class="literal">-</span> <span class="comment">支持当前事务，如果当前没有事务，就抛出异常。</span> 
<span class="comment">PROPAGATION_REQUIRES_NEW</span> <span class="literal">-</span><span class="literal">-</span> <span class="comment">新建事务，如果当前存在事务，把当前事务挂起。</span> 
<span class="comment">PROPAGATION_NOT_SUPPORTED</span> <span class="literal">-</span><span class="literal">-</span> <span class="comment">以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</span> 
<span class="comment">PROPAGATION_NEVER</span> <span class="literal">-</span><span class="literal">-</span> <span class="comment">以非事务方式执行，如果当前存在事务，则抛出异常。</span> 
<span class="comment">PROPAGATION_NESTED</span> <span class="literal">-</span><span class="literal">-</span> <span class="comment">如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则进行与PROPAGATION_REQUIRED类似的操作。</span> 
<span class="comment">前六个策略类似于EJB</span> <span class="comment">CMT，第七个（PROPAGATION_NESTED）是Spring所提供的一个特殊变量。</span> 
<span class="comment">它要求事务管理器或者使用JDBC</span> <span class="comment">3</span><span class="string">.</span><span class="comment">0</span> <span class="comment">Savepoint</span> <span class="comment">API提供嵌套事务行为（如Spring的DataSourceTransactionManager）</span>
</pre></td></tr></table></figure>

<p>如果不支持当前事务，抛异常</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="keyword">if</span> (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NEVER) { 
    		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalTransactionStateException(
					<span class="string">"Existing transaction found for transaction marked with propagation 'never'"</span>);
}
</pre></td></tr></table></figure>

<p>如果不需要事务，则挂起当前事务，返回一个不需要事务的TransactionStatus</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="keyword">if</span> (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NOT_SUPPORTED) {
    		Object suspendedResources = suspend(transaction);
			<span class="keyword">boolean</span> newSynchronization = (getTransactionSynchronization() == SYNCHRONIZATION_ALWAYS);
			<span class="keyword">return</span> newTransactionStatus(
					definition, <span class="keyword">null</span>, <span class="keyword">false</span>, newSynchronization, debugEnabled, suspendedResources); <span class="comment">//注意第二参数为null</span>
}
</pre></td></tr></table></figure>

<p>如果需要创建一个新事务，则首先挂起当前事务，然后调用子类doBegin()方法重新定义transaction，最后封装成TransactionStatus中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td><td class="code"><pre><span class="keyword">if</span> (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW) {
    		
	SuspendedResourcesHolder suspendedResources = suspend(transaction);
	<span class="keyword">try</span> {
		doBegin(transaction, definition);
	}
	<span class="keyword">catch</span> (TransactionException beginEx) {
		<span class="keyword">try</span> {
			resume(transaction, suspendedResources);
		}
		<span class="keyword">catch</span> (TransactionException resumeEx) {
			<span class="keyword">throw</span> resumeEx;
		}
		<span class="keyword">throw</span> beginEx;
	}
	<span class="keyword">boolean</span> newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER);
	<span class="keyword">return</span> newTransactionStatus(
					definition, transaction, <span class="keyword">true</span>, newSynchronization, debugEnabled, suspendedResources);
}
</pre></td></tr></table></figure>

<p>在DataSourceTransactionManager.doBegin()实现中，会判断当前事务没有绑定Connection，如果没有，则通过dataSource获取新的连接，然后会根据事务定义的属性，如隔离级别，超时时间设置到Connection中，并将Connection的自动提交设置为false（setAutoCommit(false)),最后会调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>TransactionSynchronizationManager.bindResource(getDataSource(), txObject.getConnectionHolder());
</pre></td></tr></table></figure>

<p>将新产生的ConnectionHolder采用ThreadLocal的方式绑定到当前线程中。这也就回答了我们前面提出的问题。<br>对于传播行为是PROPAGATION_NESTED，即嵌套事务</p>
<blockquote>
<p>嵌套事务是已经存在事务的一个真正的子事务. 潜套事务开始执行时,  它将取得一个 savepoint. 如果这个嵌套事务失败, 我们将回滚到此 savepoint. 潜套事务是外部事务的一部分, 只有外部事务结束后它才会被提交. </p>
</blockquote>
<p>由定义可知，它会先检查底层事务资源是否支持savepoint，支持则创建在当前事务上创建一个TransactionStatus，并创建并保存嵌套事务开始的savepoint，便于后面回滚操作。对于不支持savepoint的资源，直接创建事务状态返回。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre></td><td class="code"><pre><span class="keyword">if</span> (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) {
    <span class="keyword">if</span> (!isNestedTransactionAllowed()) {
		<span class="keyword">throw</span> <span class="keyword">new</span> NestedTransactionNotSupportedException(
						<span class="string">"Transaction manager does not allow nested transactions by default - "</span> +
						<span class="string">"specify 'nestedTransactionAllowed' property with value 'true'"</span>);
	}
			
	<span class="keyword">if</span> (useSavepointForNestedTransaction()) {
		<span class="comment">// Create savepoint within existing Spring-managed transaction,</span>
		<span class="comment">// through the SavepointManager API implemented by TransactionStatus.</span>
		<span class="comment">// Usually uses JDBC 3.0 savepoints. Never activates Spring synchronization.</span>
		DefaultTransactionStatus status =
						newTransactionStatus(definition, transaction, <span class="keyword">false</span>, <span class="keyword">false</span>, debugEnabled, <span class="keyword">null</span>);
		status.createAndHoldSavepoint();
		<span class="keyword">return</span> status;
	}
	<span class="keyword">else</span> {
		<span class="comment">// Nested transaction through nested begin and commit/rollback calls.</span>
		<span class="comment">// Usually only for JTA: Spring synchronization might get activated here</span>
		<span class="comment">// in case of a pre-existing JTA transaction.</span>
		doBegin(transaction, definition);
		<span class="keyword">boolean</span> newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER);
		<span class="keyword">return</span> newTransactionStatus(definition, transaction, <span class="keyword">true</span>, newSynchronization, debugEnabled, <span class="keyword">null</span>);
	}
}
</pre></td></tr></table></figure>

<p>对于其他情况，都会直接构建TransactionStatus返回。</p>
<p><strong>b. 当前事务不存在</strong><br>对于当前事务不存在的情况 即isExistingTransaction()返回false的情况下。<br>在事务传播行为为PROPAGATION_REQUIRED，PROPAGATION_REQUIRES_NEW，PROPAGATION_NESTED下，会先调用一个入参为null的suspend(null) 方法，参考suspend源码可以知道，这样做实际上为了给注册在TransactionSynchronizationManager中注册的TransactionSynchronization一个事件触发。<br>从TransactionSynchronization接口定义可以看到它主要关注以下事件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TransactionSynchronization</span> {</span>
<span class="keyword">void</span> suspend();<span class="comment">//事务挂起事件</span>
<span class="keyword">void</span> resume();<span class="comment">//事务恢复事件</span>
<span class="keyword">void</span> beforeCommit(<span class="keyword">boolean</span> readOnly);<span class="comment">//事务提交之前</span>
<span class="keyword">void</span> beforeCompletion();<span class="comment">//事务提交或回滚之前</span>
<span class="keyword">void</span> afterCommit();<span class="comment">//事务提交之后</span>
<span class="keyword">void</span> afterCompletion(<span class="keyword">int</span> status);<span class="comment">//事务提交或回滚完成后</span>
}
</pre></td></tr></table></figure>

<p>事务挂起的操作因具体的事务资源的不同而不同，因此具体的挂起逻辑交由子类实现，子类会将挂起的当前事务资源返回，最后被封装到SuspendedResourcesHolder中。若在在调用doBegin过程中出现异常，则通过resume()方法恢复被挂起的事务，这里还是会先给TransactionSynchronizationManager中注册的TransactionSynchronization一个事件触发，具体恢复工作交由子类实现。</p>
<h3 id="2-4-2_事务回滚">2.4.2 事务回滚</h3>
<p>rollback()方法的主要逻辑是在processRollback()中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</pre></td><td class="code"><pre><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processRollback</span>(DefaultTransactionStatus status) {
    <span class="keyword">try</span> {
		<span class="keyword">try</span> {
			triggerBeforeCompletion(status);
			<span class="keyword">if</span> (status.hasSavepoint()) {
				status.rollbackToHeldSavepoint();
			}
			<span class="keyword">else</span> <span class="keyword">if</span> (status.isNewTransaction()) {
				doRollback(status);
			}
			<span class="keyword">else</span> <span class="keyword">if</span> (status.hasTransaction()) {
				<span class="keyword">if</span> (status.isLocalRollbackOnly() || isGlobalRollbackOnParticipationFailure()) {
					doSetRollbackOnly(status);
				}
			}
				
		}
		<span class="keyword">catch</span> (RuntimeException ex) {
			triggerAfterCompletion(status, TransactionSynchronization.STATUS_UNKNOWN);
			<span class="keyword">throw</span> ex;
		}
		<span class="keyword">catch</span> (Error err) {
			triggerAfterCompletion(status, TransactionSynchronization.STATUS_UNKNOWN);
			<span class="keyword">throw</span> err;
		}
		triggerAfterCompletion(status, TransactionSynchronization.STATUS_ROLLED_BACK);
	}
	<span class="keyword">finally</span> {
			cleanupAfterCompletion(status);
	}
}
</pre></td></tr></table></figure>

<p>总结起来，对于processRollback方法，实际上做了3个工作<br>触发TransactionSynchronization事件<br>在事务回滚开始工作之前，触发beforeCompletion事件<br>事务回滚工作结束之后，清理工作之前，触发afterCompletion事件。<br>同样创建事务的事件触发一样，是通过TransactionSynchronizationManager来进行。<br>回滚事务<br>回滚事务分为几种情况：<br><strong>1.</strong>若事务是嵌套事务，则回滚到上一个savepoint<br><strong>2.</strong>若TransactionStatus中状态表示这是一个新事务，则将回滚的逻辑交由子类实现。很明显，对于DataSourceTransactionManager最终会调用Connection.rollback()方法实现事务回滚。<br><strong>3.</strong>对于其他存在事务的情况，则将事务被设置为rollbackOnly，就通过子类来实现doSetRollbackOnly。DataSourceTransactionManager中，实际上就是将保存在TransactionStatus中的DataSourceTransactionObject对象设置为rollbackOnly<br>在finally中清理进行事务清理</p>
<ol>
<li>设置TransactionStatus为completed</li>
<li>清理TransactionSynchronizationManager</li>
<li>在当前事务之前有事务挂起，则恢复。</li>
</ol>
<h3 id="2-4-3_事务提交">2.4.3 事务提交</h3>
<p>这里有两种情况：<br>一种是事务设置为rollbackOnly, 设置了这个状态后，事务的意图已经很明显，即进行回滚，因此它就直接调用processRollback()方法回滚<br>另一种就是提交，它涉及到：<br><strong>1.</strong>从TransactionSynchronization接口已经知道，对于事务提交，它会关注4个事件。先后关系为：<br>beforeCommit-》beforeCompletion-》提交操作-》afterCompletion-》afterCommit<br><strong>2.</strong>对于嵌套事务，清除savePoint，此时事务不应该提交，提交操作应交由外部的事务来处理。<br><strong>3.</strong>对于新事务，将提交操作交由子类来进行。很明显，基于DataSourceTransactionManager最后会将提交操作落实到Connection.commit()方法。</p>
<h2 id="2-4-_偷梁换柱之Connection管理">2.4. 偷梁换柱之Connection管理</h2>
<p>针对于DataSourceTransactionManager，虽然spring通过dataSource获取了Connection，并进行了事务相关属性的配置，如何影响到targetClass执行的代码？且看spring是如何在底层将Connection偷梁换柱的。<br>我们知道，基于Datasource的事务管理，最终都会交由Connection来处理。若spring在事务管理器中设置的Connection，与最终DAO所用的Connection不是同一个Connection，那么Spring就白忙活了，DAO是不会听事务的控制的，该干嘛干嘛。<br>为了避免这样的情况，Spring再一次采取了它的强有力的方式—代理。</p>
<h3 id="2-4-1_在DataSource上动手脚">2.4.1 在DataSource上动手脚</h3>
<p>基于IBatis的数据库访问方式中，我们通常会采用这样的方式获取sqlMapClient对象</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre>     <span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"sqlMapClient"</span> <span class="attribute">class</span>=<span class="value">"org.springframework.orm.ibatis.SqlMapClientFactoryBean"</span>&gt;</span>
    	<span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"configLocation"</span>&gt;</span> 
			<span class="tag">&lt;<span class="title">bean</span> <span class="attribute">class</span>=<span class="value">"org.springframework.core.io.ClassPathResource"</span>&gt;</span> 
				<span class="tag">&lt;<span class="title">constructor-arg</span>&gt;</span><span class="tag">&lt;<span class="title">value</span>&gt;</span>/sqlmap/sqlmap-auth-config.xml<span class="tag">&lt;/<span class="title">value</span>&gt;</span><span class="tag">&lt;/<span class="title">constructor-arg</span>&gt;</span> 
			<span class="tag">&lt;/<span class="title">bean</span>&gt;</span>
		<span class="tag">&lt;/<span class="title">property</span>&gt;</span>
		<span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"dataSource"</span>&gt;</span>
			<span class="tag">&lt;<span class="title">ref</span> <span class="attribute">local</span>=<span class="value">"dataSource"</span> /&gt;</span>
		<span class="tag">&lt;/<span class="title">property</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">bean</span>&gt;</span>
</pre></td></tr></table></figure>

<p>对，又是一个FactoryBean，可以知道它肯定又作了代理。<br>SqlMapClientFactoryBean实现了FactoryBean和InitializingBean两个接口，它将创建sqlMapClient的逻辑放到了afterPropertiesSet()方法中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span>() <span class="keyword">throws</span> Exception {
	... ...

    <span class="keyword">this</span>.sqlMapClient = buildSqlMapClient(<span class="keyword">this</span>.configLocations, <span class="keyword">this</span>.mappingLocations, <span class="keyword">this</span>.sqlMapClientProperties);

    <span class="comment">// Tell the SqlMapClient to use the given DataSource, if any.</span>
	<span class="keyword">if</span> (<span class="keyword">this</span>.dataSource != <span class="keyword">null</span>) {
		TransactionConfig transactionConfig = (TransactionConfig) <span class="keyword">this</span>.transactionConfigClass.newInstance();
		DataSource dataSourceToUse = <span class="keyword">this</span>.dataSource;
		<span class="keyword">if</span> (<span class="keyword">this</span>.useTransactionAwareDataSource && !(<span class="keyword">this</span>.dataSource <span class="keyword">instanceof</span> TransactionAwareDataSourceProxy)) {
			dataSourceToUse = <span class="keyword">new</span> TransactionAwareDataSourceProxy(<span class="keyword">this</span>.dataSource);
		}
		transactionConfig.setDataSource(dataSourceToUse);
		transactionConfig.initialize(<span class="keyword">this</span>.transactionConfigProperties);
		applyTransactionConfig(<span class="keyword">this</span>.sqlMapClient, transactionConfig);
	}
	... ... 
}
</pre></td></tr></table></figure>

<p>首先通过buildSqlMapClient()创建sqlMapClient，这里面实际上就是通常的ibatis初始化工作，SqlMapconfigParser解析sqlmapconfig.xml配置文件，便可得到实例化后的sqlMapClient. 另外，SqlMapClientFactoryBean还支持直接指定sqlMap映射文件。至于如何解析ibatis配置文件及sqlMapClient的实例化过程，不在本篇讨论范围之内，后面会另外专门讨论。<br>得到sqlMapClient后，会检查是否指定了datasource属性，如果指定了就用指定的datasource设置到sqlMapClient中。这里并不会直接交给sqlmapClient一个原生的dataSource，而是动过手脚之后的。<br>首先，spring会用TransactionAwareDataSourceProxy把原生的数据源包裹起来，然后把它设置到ibatis的事务配置里面，当作事务的数据源。然后初始化事务配置:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>transactionConfig.initialize(<span class="keyword">this</span>.transactionConfigProperties);
</pre></td></tr></table></figure>

<p>可以看到在SqlMapClientFactoryBean构造方法中初始化transactionConfigProperties的内容：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="keyword">this</span>.transactionConfigProperties.setProperty(<span class="string">"SetAutoCommitAllowed"</span>, <span class="string">"false"</span>);
</pre></td></tr></table></figure>

<p>很明显，不允许自动提交。<br>最后用替换掉Ibatis本身的事务管理器，干净利落！</p>
<p>且来看看TransactionAwareDataSourceProxy做了些什么事情。<br>类结构图：<br><img src="http://tanfeng.qiniudn.com/blog/2014/08/20130602172816390.png" alt="TransactionAwareDataSourceProxy类结构图"><br>可以看出是典型的代理设计模式。</p>
<p>对于getConnection方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="keyword">public</span> Connection <span class="title">getConnection</span>() <span class="keyword">throws</span> SQLException {
    	DataSource ds = getTargetDataSource();
		Assert.state(ds != <span class="keyword">null</span>, <span class="string">"'targetDataSource' is required"</span>);
		<span class="keyword">return</span> getTransactionAwareConnectionProxy(ds);
}
</pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="keyword">protected</span> Connection <span class="title">getTransactionAwareConnectionProxy</span>(DataSource targetDataSource) {
    	<span class="keyword">return</span> (Connection) Proxy.newProxyInstance(
				ConnectionProxy.class.getClassLoader(),
				<span class="keyword">new</span> Class[] {ConnectionProxy.class},
				<span class="keyword">new</span> TransactionAwareInvocationHandler(targetDataSource));
}
</pre></td></tr></table></figure>

<p>采用的是jdk的动态代理方式，具体的代理逻辑封装在TransactionAwareInvocationHandler中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
</pre></td><td class="code"><pre><span class="keyword">public</span> Object <span class="title">invoke</span>(Object proxy, Method method, Object[] args) <span class="keyword">throws</span> Throwable {
    <span class="comment">//... ... 对于equals,hashCode等方法的代理</span>
    <span class="keyword">else</span> <span class="keyword">if</span> (method.getName().equals(<span class="string">"close"</span>)) {
    <span class="comment">// Handle close method: only close if not within a transaction.</span>
		DataSourceUtils.doReleaseConnection(<span class="keyword">this</span>.target, <span class="keyword">this</span>.targetDataSource);
		<span class="keyword">this</span>.closed = <span class="keyword">true</span>;
		<span class="keyword">return</span> <span class="keyword">null</span>;
	}

	<span class="keyword">if</span> (<span class="keyword">this</span>.target == <span class="keyword">null</span>) {
		<span class="keyword">if</span> (<span class="keyword">this</span>.closed) {
			<span class="keyword">throw</span> <span class="keyword">new</span> SQLException(<span class="string">"Connection handle already closed"</span>);
		}
		<span class="keyword">if</span> (shouldObtainFixedConnection(<span class="keyword">this</span>.targetDataSource)) {
					<span class="keyword">this</span>.target = DataSourceUtils.doGetConnection(<span class="keyword">this</span>.targetDataSource);
		}
	}
	Connection actualTarget = <span class="keyword">this</span>.target;
	<span class="keyword">if</span> (actualTarget == <span class="keyword">null</span>) {
		actualTarget = DataSourceUtils.doGetConnection(<span class="keyword">this</span>.targetDataSource);
	}

	<span class="keyword">if</span> (method.getName().equals(<span class="string">"getTargetConnection"</span>)) {
		<span class="comment">// Handle getTargetConnection method: return underlying Connection.</span>
		<span class="keyword">return</span> actualTarget;
	}

	<span class="comment">// Invoke method on target Connection.</span>
	<span class="keyword">try</span> {
		Object retVal = method.invoke(actualTarget, args);

		<span class="comment">// If return value is a Statement, apply transaction timeout.</span>
		<span class="comment">// Applies to createStatement, prepareStatement, prepareCall.</span>
		<span class="keyword">if</span> (retVal <span class="keyword">instanceof</span> Statement) {
			DataSourceUtils.applyTransactionTimeout((Statement) retVal, <span class="keyword">this</span>.targetDataSource);
		}

		<span class="keyword">return</span> retVal;
	}
	<span class="keyword">catch</span> (InvocationTargetException ex) {
		<span class="keyword">throw</span> ex.getTargetException();
	}
	<span class="keyword">finally</span> {
		<span class="keyword">if</span> (actualTarget != <span class="keyword">this</span>.target) {
			DataSourceUtils.doReleaseConnection(actualTarget, <span class="keyword">this</span>.targetDataSource);
		}
	}
}
</pre></td></tr></table></figure>

<p>TransactionAwareInvocationHandler中invoke方法的代码中可以看到：<br>对于代理对象的close方法，直接调用DataSourceUtils.doReleaseConnection()方法释放连接，在DataSourceUtils.doReleaseConnection()方法中，实际上最后会通过TransactionSynchronizationManager来获取绑定到ThreadLocal中的ConnectionHolder，并释放。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre>    	<span class="keyword">if</span> (dataSource != <span class="keyword">null</span>) {
			ConnectionHolder conHolder = (ConnectionHolder) TransactionSynchronizationManager.getResource(dataSource);
			<span class="keyword">if</span> (conHolder != <span class="keyword">null</span> && connectionEquals(conHolder, con)) {
				<span class="comment">// It's the transactional Connection: Don't close it.</span>
				conHolder.released();
				<span class="keyword">return</span>;
			}
	    }
</pre></td></tr></table></figure>

<p>同样，对于DataSourceUtils.doGetConnection()，最后也是通过TransactionSynchronizationManager.getResource()方法获取绑定到当前线程的Connection<br>在前面讲到过在事务创建阶段，DataSourceTransactionManager的方法doBegin()中会将当前事务相关的Connection绑定到当前线程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>TransactionSynchronizationManager.bindResource(getDataSource(), txObject.getConnectionHolder());
</pre></td></tr></table></figure>

<p>这里在DAO访问数据库过程中实际上会通过调用<code>TransactionSynchronizationManager.getResource(dataSource)</code>获取当前事务绑定的Connection，前后形成呼应，因此事务就这样偷偷的生效了。</p>
<h3 id="2-4-2_模板方法中的替换">2.4.2 模板方法中的替换</h3>
<p>对于基于IBatis的数据访问方式，Spring为我们提供了一个方便用于数据库访问的模板类SqlMapClientTemplate。<br>该类提供一个基于回调的模板方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
</pre></td><td class="code"><pre><span class="keyword">public</span> Object <span class="title">execute</span>(SqlMapClientCallback action) <span class="keyword">throws</span> DataAccessException {
	<span class="comment">//... ...</span>
    SqlMapSession session = <span class="keyword">this</span>.sqlMapClient.openSession();
   	<span class="keyword">if</span> (logger.isDebugEnabled()) {
		logger.debug(<span class="string">"Opened SqlMapSession ["</span> + session + <span class="string">"] for iBATIS operation"</span>);
	}
	Connection ibatisCon = <span class="keyword">null</span>;

	<span class="keyword">try</span> {
		Connection springCon = <span class="keyword">null</span>;
		DataSource dataSource = getDataSource();
		<span class="keyword">boolean</span> transactionAware = (dataSource <span class="keyword">instanceof</span> TransactionAwareDataSourceProxy);

		<span class="comment">// Obtain JDBC Connection to operate on...</span>
		<span class="keyword">try</span> {
			ibatisCon = session.getCurrentConnection();
			<span class="keyword">if</span> (ibatisCon == <span class="keyword">null</span>) {
				springCon = (transactionAware ?
						dataSource.getConnection() : DataSourceUtils.doGetConnection(dataSource));
				session.setUserConnection(springCon);
			}
            <span class="keyword">try</span> {
				<span class="keyword">return</span> action.doInSqlMapClient(session);
			}
			<span class="keyword">catch</span> (SQLException ex) {
				<span class="keyword">throw</span> getExceptionTranslator().translate(<span class="string">"SqlMapClient operation"</span>, <span class="keyword">null</span>, ex);
			}
			<span class="keyword">finally</span> {
				<span class="keyword">try</span> {
					<span class="keyword">if</span> (springCon != <span class="keyword">null</span>) {
						<span class="keyword">if</span> (transactionAware) {
							springCon.close();
						}
						<span class="keyword">else</span> {
							DataSourceUtils.doReleaseConnection(springCon, dataSource);
						}
					}
				}
				<span class="keyword">catch</span> (Throwable ex) {
					
				}
			}
}
</pre></td></tr></table></figure>

<p>可以看到这里把获取dataSource的过程封装起来，对于直接给SqlMapClientTemplate设置的dataSource，在获取Connection时，又是通过DataSourceUtils.doGetConnection()方法获取，最终获取的是又是TransactionSynchronizationManager中绑定的Connection对象。否则，若dataSource是从sqlMapClient中获取的，此时dataSource已经是被代理的DataSource了。然后把Connection设置到SqlMapSession对象中，使此次操作在事务过程中。<br>对于最后connection的释放，若dataSource是被代理的dataSource（TransactionAwareDataSourceProxy），则直接调用它的close方法，从前文中的分析中可以知道，该close方法最后会通过DataSourceUtils.doReleaseConnection()来释放连接。<br>通过多个方面的措施，最终spring就能保证目标DAO的操作都在Spring事务管理器的控制范围内。</p>
<h3 id="3-_总结">3. 总结</h3>
<p>万变不离其宗，对于基于DataSource的事务管理，最终的简化后的逻辑就是我们在 2.1节中总结原生jdbc事务管理方式。spring只是对原生方式进行各种抽象及封装，通过AOP，利用IOC提供的方便，最终可以让用户方便的使用事务管理的方式。    </p>
  
	</div>
		<footer class="article-footer clearfix">

  <div class="article-tags">
  
  <span></span> <a href="/tags/Spring/">Spring</a>
  </div>


<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/开源框架/">开源框架</a>
</div>



<div class="article-share" id="share">

  <div data-url="itanfeng.cn/2014/08/17/spring-code-transaction-2/" data-title="Spring事务分析(2)--基于声明式的事务管理实现分析 | 谭锋的博客" data-tsina="null" class="share clearfix">
  </div>

</div>
</footer>   	       
	</article>
	
<nav class="article-nav clearfix">
 

<div class="next">
<a href="/2014/08/17/spring-source-transaction-1/"  title="Spring事务分析(1)--统一事务接口">
 <strong>NEXT:</strong><br/> 
 <span>Spring事务分析(1)--统一事务接口
</span>
</a>
</div>

</nav>

	
<section class="comment">
	<div class="ds-thread"></div>
</section>

</div>  

      <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>

  <div id="toc" class="toc-aside">
  <strong class="toc-title">文章目录</strong>
  <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-_例子"><span class="toc-number">1.</span> <span class="toc-text">1. 例子</span></a></li><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1_datasource配置"><span class="toc-number">1.1.</span> <span class="toc-text">1.1 datasource配置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2_事务aop部分"><span class="toc-number">1.2.</span> <span class="toc-text">1.2 事务aop部分</span></a></li><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-1_目标对象类代码："><span class="toc-number">1.2.1.</span> <span class="toc-text">1.2.1 目标对象类代码：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-2_配置"><span class="toc-number">1.2.2.</span> <span class="toc-text">1.2.2 配置</span></a></li></ol></ol><li class="toc-item toc-level-1"><a class="toc-link" href="#2-_探究事务内部实现原理"><span class="toc-number">2.</span> <span class="toc-text">2. 探究事务内部实现原理</span></a></li><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1_原生jdbc事务管理方式"><span class="toc-number">2.1.</span> <span class="toc-text">2.1 原生jdbc事务管理方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2_事务代理对象的创建"><span class="toc-number">2.2.</span> <span class="toc-text">2.2 事务代理对象的创建</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3_横切逻辑的织入"><span class="toc-number">2.3.</span> <span class="toc-text">2.3 横切逻辑的织入</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4_事务管理器"><span class="toc-number">2.4.</span> <span class="toc-text">2.4 事务管理器</span></a></li><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-1_创建事务"><span class="toc-number">2.4.1.</span> <span class="toc-text">2.4.1 创建事务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-2_事务回滚"><span class="toc-number">2.4.2.</span> <span class="toc-text">2.4.2 事务回滚</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-3_事务提交"><span class="toc-number">2.4.3.</span> <span class="toc-text">2.4.3 事务提交</span></a></li></ol><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-_偷梁换柱之Connection管理"><span class="toc-number">2.5.</span> <span class="toc-text">2.4. 偷梁换柱之Connection管理</span></a></li><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-1_在DataSource上动手脚"><span class="toc-number">2.5.1.</span> <span class="toc-text">2.4.1 在DataSource上动手脚</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-2_模板方法中的替换"><span class="toc-number">2.5.2.</span> <span class="toc-text">2.4.2 模板方法中的替换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-_总结"><span class="toc-number">2.5.3.</span> <span class="toc-text">3. 总结</span></a></li></ol>
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div>
<aside class="clearfix">

  
<div class="tagslist">
	<p class="asidetitle">标签</p>
		<ul class="clearfix">
		
			<li><a href="/tags/JAVA/" title="JAVA">JAVA<sup>3</sup></a></li>
		
			<li><a href="/tags/JVM/" title="JVM">JVM<sup>1</sup></a></li>
		
			<li><a href="/tags/Spring/" title="Spring">Spring<sup>5</sup></a></li>
		
			<li><a href="/tags/并发/" title="并发">并发<sup>2</sup></a></li>
		
		</ul>
</div>


  
<div class="categorieslist">
	<p class="asidetitle">分类</p>
		<ul>
		
			<li><a href="/categories/开源框架/" title="开源框架">开源框架<sup>5</sup></a></li>
		
			<li><a href="/categories/编程语言/" title="编程语言">编程语言<sup>3</sup></a></li>
		
		</ul>
</div>


  
  <div class="archiveslist">
    <p class="asidetitle"><a href="/archives">归档</a></p>
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/08">八月 2014</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/07">七月 2014</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/02">二月 2013</a><span class="archive-list-count">5</span></li></ul>
  </div>


  <div class="rsspart">
	<a href="itanfeng.cn" target="_blank" title="rss">RSS 订阅</a>
</div>

</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	
	<div class="social-font" class="clearfix">
		
		<a href="http://weibo.com/2939434270" target="_blank" title="weibo"></a>
		
		
		
		
	</div>
		<p class="copyright">Powered by <a href="http://zespia.tw/hexo/" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/A-limon/pacman" target="_blank" title="Pacman">Pacman</a> © 2014 
		
		<a href="itanfeng.cn" target="_blank" title="tanfeng">tanfeng</a>
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.1.0.min.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else
    {
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
      
      $('#toc.toc-aside').css('display', 'none');
        
    }
  });
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      h  = $('article h2')
      ah = $('article h2'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  if(ah.length==0){
    t.css('display','none');
  }else{
    c.click(function(){
      ta.css('display', 'block').addClass('fadeIn');
    });
    o.click(function(){
      ta.css('display', 'none');
    });
    $(window).scroll(function(){
      ta.css("top",Math.max(140,320-$(this).scrollTop()));
    });
  };
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina');
  var html = [
  '<a href="#" class="overlay" id="qrcode"></a>',
  '<div class="qrcode clearfix"><span>扫描二维码分享到微信朋友圈</span><a class="qrclose" href="#share"></a><strong>Loading...Please wait</strong><img id="qrcode-pic" data-src="http://s.jiathis.com/qrcode.php?url=' + encodedUrl + '"/></div>',
  '<a href="#textlogo" class="article-back-to-top" title="Top"></a>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="QRcode"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="Weibo"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);
  $('.article-share-qrcode').click(function(){
    var imgSrc = $('#qrcode-pic').attr('data-src');
    $('#qrcode-pic').attr('src', imgSrc);
    $('#qrcode-pic').load(function(){
        $('.qrcode strong').text(' ');
    });
  });
});     
</script>


<script type="text/javascript">
  var duoshuoQuery = {short_name:"jianchiblog"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
    || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
</script> 



<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



  </body>
</html>
